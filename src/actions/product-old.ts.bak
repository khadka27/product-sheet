"use server";

import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { db } from "@/lib/db";
import { generateSlug, ensureUniqueSlug } from "@/lib/utils";
import {
  ProductCreate,
  ProductUpdate,
  CsvRowInput,
  type CsvImportResultType,
} from "@/lib/validations";
import Papa from "papaparse";

interface CreateProductResult {
  success: boolean;
  data?: { id: string };
  error?: string;
}

export async function createProduct(
  formData: FormData
): Promise<CreateProductResult> {
  try {
    // Extract form data
    const rawData = {
      name: formData.get("name") as string,
      description: formData.get("description") as string,
      price: formData.get("price") as string,
      currency: (formData.get("currency") as string) || "USD",
      stock: formData.get("stock") as string,
      category: formData.get("category") as string,
      tags: formData.get("tags") as string,
    };

    // Parse and validate
    const validated = ProductCreate.parse({
      ...rawData,
      price: parseFloat(rawData.price || "0"),
      stock: parseInt(rawData.stock || "0"),
      tags: rawData.tags
        ? rawData.tags
            .split(",")
            .map((tag) => tag.trim())
            .filter(Boolean)
        : [],
    });

    // Generate slug
    const baseSlug = generateSlug(validated.name);
    const existingSlugs = await db.product
      .findMany({
        select: { slug: true },
      })
      .then((products: { slug: string }[]) =>
        products.map((p: { slug: string }) => p.slug)
      );
    const slug = ensureUniqueSlug(baseSlug, existingSlugs);

    // Handle category
    let categoryId: string | undefined;
    if (validated.category) {
      const category = await db.category.upsert({
        where: { name: validated.category },
        update: {},
        create: {
          name: validated.category,
          slug: generateSlug(validated.category),
        },
      });
      categoryId = category.id;
    }

    // Handle tags
    const tagIds: string[] = [];
    if (validated.tags && validated.tags.length > 0) {
      for (const tagName of validated.tags) {
        const tag = await db.tag.upsert({
          where: { name: tagName },
          update: {},
          create: {
            name: tagName,
            slug: generateSlug(tagName),
          },
        });
        tagIds.push(tag.id);
      }
    }

    // Create product
    const product = await db.product.create({
      data: {
        name: validated.name,
        slug,
        description: validated.description,
        price: validated.price,
        currency: validated.currency,
        stock: validated.stock,
        categoryId,
        tags: {
          create: tagIds.map((tagId) => ({ tagId })),
        },
      },
    });

    revalidatePath("/");
    return { success: true, data: { id: product.id } };
  } catch (error) {
    console.error("Error creating product:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "Failed to create product",
    };
  }
}

export async function updateProduct(
  id: string,
  formData: FormData
): Promise<CreateProductResult> {
  try {
    // Extract form data
    const rawData = {
      id,
      sku: formData.get("sku") as string,
      name: formData.get("name") as string,
      description: formData.get("description") as string,
      price: formData.get("price") as string,
      currency: (formData.get("currency") as string) || "USD",
      stock: formData.get("stock") as string,
      category: formData.get("category") as string,
      tags: formData.get("tags") as string,
    };

    // Parse and validate
    const validated = ProductUpdate.parse({
      ...rawData,
      price: parseFloat(rawData.price),
      stock: parseInt(rawData.stock),
      tags: rawData.tags
        ? rawData.tags
            .split(",")
            .map((tag) => tag.trim())
            .filter(Boolean)
        : [],
    });

    // Check if product exists
    const existingProduct = await db.product.findUnique({
      where: { id },
      include: { tags: true },
    });

    if (!existingProduct) {
      return { success: false, error: "Product not found" };
    }

    // Check if SKU is taken by another product
    if (validated.sku && validated.sku !== existingProduct.sku) {
      const skuTaken = await db.product.findFirst({
        where: {
          sku: validated.sku,
          id: { not: id },
        },
      });

      if (skuTaken) {
        return {
          success: false,
          error: "SKU is already taken by another product",
        };
      }
    }

    // Generate new slug if name changed
    let slug = existingProduct.slug;
    if (validated.name && validated.name !== existingProduct.name) {
      const baseSlug = generateSlug(validated.name);
      const existingSlugs = await db.product
        .findMany({
          where: { id: { not: id } },
          select: { slug: true },
        })
        .then((products: { slug: string }[]) =>
          products.map((p: { slug: string }) => p.slug)
        );
      slug = ensureUniqueSlug(baseSlug, existingSlugs);
    }

    // Handle category
    let categoryId: string | null = existingProduct.categoryId;
    if (validated.category !== undefined) {
      if (validated.category) {
        const category = await db.category.upsert({
          where: { name: validated.category },
          update: {},
          create: {
            name: validated.category,
            slug: generateSlug(validated.category),
          },
        });
        categoryId = category.id;
      } else {
        categoryId = null;
      }
    }

    // Handle tags
    let tagOperations = {};
    if (validated.tags !== undefined) {
      // Remove existing tags
      await db.productTag.deleteMany({
        where: { productId: id },
      });

      // Add new tags
      if (validated.tags.length > 0) {
        const tagIds: string[] = [];
        for (const tagName of validated.tags) {
          const tag = await db.tag.upsert({
            where: { name: tagName },
            update: {},
            create: {
              name: tagName,
              slug: generateSlug(tagName),
            },
          });
          tagIds.push(tag.id);
        }

        tagOperations = {
          tags: {
            create: tagIds.map((tagId) => ({ tagId })),
          },
        };
      }
    }

    // Update product
    const product = await db.product.update({
      where: { id },
      data: {
        ...(validated.sku && { sku: validated.sku }),
        ...(validated.name && { name: validated.name, slug }),
        ...(validated.description !== undefined && {
          description: validated.description,
        }),
        ...(validated.price !== undefined && { price: validated.price }),
        ...(validated.currency && { currency: validated.currency }),
        ...(validated.stock !== undefined && { stock: validated.stock }),
        ...(categoryId !== existingProduct.categoryId && { categoryId }),
        ...tagOperations,
      },
    });

    revalidatePath("/");
    revalidatePath(`/products/${id}`);
    return { success: true, data: { id: product.id } };
  } catch (error) {
    console.error("Error updating product:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "Failed to update product",
    };
  }
}

export async function deleteProduct(
  id: string
): Promise<{ success: boolean; error?: string }> {
  try {
    await db.product.delete({
      where: { id },
    });

    revalidatePath("/");
    return { success: true };
  } catch (error) {
    console.error("Error deleting product:", error);
    return {
      success: false,
      error: "Failed to delete product",
    };
  }
}

export async function bulkUpsertProducts(
  csvData: string
): Promise<CsvImportResultType> {
  try {
    // Parse CSV
    const parseResult = Papa.parse(csvData, {
      header: true,
      skipEmptyLines: true,
      transformHeader: (header) => header.toLowerCase().trim(),
    });

    if (parseResult.errors.length > 0) {
      return {
        success: false,
        totalRows: 0,
        successfulRows: 0,
        failedRows: 0,
        errors: parseResult.errors.map((error, index) => ({
          row: index + 1,
          errors: [error.message],
        })),
      };
    }

    const rows = parseResult.data as Record<string, string>[];
    const result: CsvImportResultType = {
      success: true,
      totalRows: rows.length,
      successfulRows: 0,
      failedRows: 0,
      errors: [],
    };

    // Process each row
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      const rowNumber = i + 1;

      try {
        // Validate row data
        const validated = CsvRowInput.parse({
          sku: row.sku?.trim(),
          name: row.name?.trim(),
          description: row.description?.trim() || undefined,
          price: row.price?.trim(),
          currency: row.currency?.trim() || "USD",
          stock: row.stock?.trim(),
          category: row.category?.trim() || undefined,
          tags: row.tags?.trim() || undefined,
        });

        // Parse tags
        const tags = validated.tags
          ? validated.tags
              .split(",")
              .map((tag) => tag.trim())
              .filter(Boolean)
          : [];

        // Generate slug
        const baseSlug = generateSlug(validated.name);
        const existingSlugs = await db.product
          .findMany({
            where: {
              slug: { startsWith: baseSlug },
              sku: { not: validated.sku },
            },
            select: { slug: true },
          })
          .then((products: { slug: string }[]) =>
            products.map((p: { slug: string }) => p.slug)
          );
        const slug = ensureUniqueSlug(baseSlug, existingSlugs);

        // Handle category
        let categoryId: string | undefined;
        if (validated.category) {
          const category = await db.category.upsert({
            where: { name: validated.category },
            update: {},
            create: {
              name: validated.category,
              slug: generateSlug(validated.category),
            },
          });
          categoryId = category.id;
        }

        // Handle tags
        const tagIds: string[] = [];
        for (const tagName of tags) {
          const tag = await db.tag.upsert({
            where: { name: tagName },
            update: {},
            create: {
              name: tagName,
              slug: generateSlug(tagName),
            },
          });
          tagIds.push(tag.id);
        }

        // Upsert product
        await db.product.upsert({
          where: { sku: validated.sku },
          update: {
            name: validated.name,
            slug,
            description: validated.description,
            price: parseFloat(validated.price),
            currency: validated.currency,
            stock: parseInt(validated.stock),
            categoryId,
            tags: {
              deleteMany: {},
              create: tagIds.map((tagId) => ({ tagId })),
            },
          },
          create: {
            sku: validated.sku,
            name: validated.name,
            slug,
            description: validated.description,
            price: parseFloat(validated.price),
            currency: validated.currency,
            stock: parseInt(validated.stock),
            categoryId,
            tags: {
              create: tagIds.map((tagId) => ({ tagId })),
            },
          },
        });

        result.successfulRows++;
      } catch (error) {
        result.failedRows++;
        result.errors.push({
          row: rowNumber,
          sku: row.sku,
          errors: [error instanceof Error ? error.message : "Unknown error"],
        });
      }
    }

    result.success = result.failedRows === 0;
    revalidatePath("/");
    return result;
  } catch (error) {
    console.error("Error in bulk upsert:", error);
    return {
      success: false,
      totalRows: 0,
      successfulRows: 0,
      failedRows: 0,
      errors: [
        {
          row: 1,
          errors: [
            error instanceof Error ? error.message : "Failed to process CSV",
          ],
        },
      ],
    };
  }
}

// Redirect actions
export async function redirectToProduct(id: string) {
  redirect(`/products/${id}`);
}

export async function redirectToHome() {
  redirect("/");
}
