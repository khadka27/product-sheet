"use server";

import { db } from "@/lib/db";
import { SearchFilters, type SearchFiltersType } from "@/lib/validations";
import {
  tokenizeQuery,
  generateLikePatterns,
  calculateSearchScore,
} from "@/lib/search/tokenize";

export interface SearchResult {
  items: Array<{
    id: string;
    sn: number;
    name: string;
    slug: string;
    description: string | null;
    price: number;
    currency: string;
    stock: number;
    category: { id: string; name: string } | null;
    tags: Array<{ tag: { id: string; name: string } }>;
    createdAt: Date;
    updatedAt: Date;
  }>;
  pagination: {
    page: number;
    limit: number;
    totalItems: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

export async function searchProducts(
  filters: SearchFiltersType
): Promise<SearchResult> {
  try {
    const validated = SearchFilters.parse(filters);
    const {
      query,
      categoryId,
      tagIds,
      minPrice,
      maxPrice,
      inStockOnly,
      sortBy,
      page,
      limit,
    } = validated;

    // Build where clause
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const where: any = {};

    // Text search
    if (query) {
      const tokens = tokenizeQuery(query);
      if (tokens.length > 0) {
        const patterns = generateLikePatterns(tokens);

        where.OR = [
          // Search in name
          ...patterns.map((pattern) => ({
            name: { contains: pattern.slice(1, -1), mode: "insensitive" },
          })),
          // Search in description
          ...patterns.map((pattern) => ({
            description: {
              contains: pattern.slice(1, -1),
              mode: "insensitive",
            },
          })),
          // Search in tags
          {
            tags: {
              some: {
                tag: {
                  name: {
                    in: tokens.map((token) => token),
                    mode: "insensitive",
                  },
                },
              },
            },
          },
        ];
      }
    }

    // Category filter
    if (categoryId) {
      where.categoryId = categoryId;
    }

    // Tag filters
    if (tagIds && tagIds.length > 0) {
      where.tags = {
        some: {
          tagId: { in: tagIds },
        },
      };
    }

    // Price range
    if (minPrice !== undefined || maxPrice !== undefined) {
      where.price = {};
      if (minPrice !== undefined) where.price.gte = minPrice;
      if (maxPrice !== undefined) where.price.lte = maxPrice;
    }

    // Stock filter
    if (inStockOnly) {
      where.stock = { gt: 0 };
    }

    // Build order by
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let orderBy: any = {};
    switch (sortBy) {
      case "price_asc":
        orderBy = { price: "asc" };
        break;
      case "price_desc":
        orderBy = { price: "desc" };
        break;
      case "newest":
        orderBy = { createdAt: "desc" };
        break;
      case "name_asc":
        orderBy = { name: "asc" };
        break;
      default:
        // For relevance, we'll sort by createdAt desc initially and then re-sort by score
        orderBy = { createdAt: "desc" };
    }

    // Get total count
    const totalItems = await db.product.count({ where });

    // Get items
    const skip = (page - 1) * limit;
    let items = await db.product.findMany({
      where,
      include: {
        category: true,
        tags: {
          include: {
            tag: true,
          },
        },
      },
      orderBy,
      skip,
      take: limit,
    });

    // If sorting by relevance and we have a query, re-sort by search score
    if (sortBy === "relevance" && query) {
      const tokens = tokenizeQuery(query);
      type ItemWithScore = (typeof items)[0] & { _score: number };

      items = (items as ItemWithScore[])
        .map((item: (typeof items)[0]) => ({
          ...item,
          _score: calculateSearchScore(item, tokens),
        }))
        .sort((a: ItemWithScore, b: ItemWithScore) => b._score - a._score)
        .map((item: ItemWithScore) => {
          // Remove _score property
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          const { _score, ...itemWithoutScore } = item;
          return itemWithoutScore;
        });
    }

    // Calculate pagination
    const totalPages = Math.ceil(totalItems / limit);
    const hasNext = page < totalPages;
    const hasPrev = page > 1;

    // Map items to match the expected return type
    const mappedItems = items.map((item) => ({
      id: item.id,
      sku: item.sku,
      name: item.name,
      slug: item.slug,
      description: item.description,
      price: Number(item.price), // Convert Decimal to number
      currency: item.currency,
      stock: item.stock,
      category: item.category
        ? {
            id: item.category.id,
            name: item.category.name,
          }
        : null,
      tags: item.tags.map((tagItem) => ({
        tag: {
          id: tagItem.tag.id,
          name: tagItem.tag.name,
        },
      })),
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
    }));

    return {
      items: mappedItems,
      pagination: {
        page,
        limit,
        totalItems,
        totalPages,
        hasNext,
        hasPrev,
      },
    };
  } catch (error) {
    console.error("Error searching products:", error);
    return {
      items: [],
      pagination: {
        page: 1,
        limit: 20,
        totalItems: 0,
        totalPages: 0,
        hasNext: false,
        hasPrev: false,
      },
    };
  }
}

export async function getSuggestions(query: string): Promise<
  Array<{
    id: string;
    name: string;
    sku: string;
    categoryName?: string;
  }>
> {
  try {
    if (!query.trim()) return [];

    const tokens = tokenizeQuery(query);
    if (tokens.length === 0) return [];

    const patterns = generateLikePatterns(tokens);

    const suggestions = await db.product.findMany({
      where: {
        OR: [
          // Search in name
          ...patterns.map((pattern) => ({
            name: { contains: pattern.slice(1, -1), mode: "insensitive" },
          })),
          // Search in SKU
          ...patterns.map((pattern) => ({
            sku: { contains: pattern.slice(1, -1), mode: "insensitive" },
          })),
        ],
      },
      include: {
        category: true,
      },
      take: 5,
    });

    return suggestions.map(
      (item: {
        id: string;
        name: string;
        sku: string;
        category: { name: string } | null;
      }) => ({
        id: item.id,
        name: item.name,
        sku: item.sku,
        categoryName: item.category?.name,
      })
    );
  } catch (error) {
    console.error("Error getting suggestions:", error);
    return [];
  }
}

export async function getCategories() {
  try {
    return await db.category.findMany({
      orderBy: { name: "asc" },
    });
  } catch (error) {
    console.error("Error fetching categories:", error);
    return [];
  }
}

export async function getTags() {
  try {
    return await db.tag.findMany({
      orderBy: { name: "asc" },
    });
  } catch (error) {
    console.error("Error fetching tags:", error);
    return [];
  }
}
